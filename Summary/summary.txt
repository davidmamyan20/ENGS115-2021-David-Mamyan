01/09/21

In the lecture, we discussed one of the videos we were supposed to watch at home. The video was about Big O notation, where the woman brought 4 steps of Big O notation 1.) Different steps get added, 2.)Drop constants, 3.) Different inputs and different variables, 4.) Drop non-dominate terms. Then we tried to understand the asymptotic notation. I understood that there are some codes, which do a lot of steps in a second, I think that is why there is a Big O notation, like O(n). Dropping constants means if O(n) becomes O(2n), it means we can simply write O(n) again, because n is not a constant number. Then we had a little discussion about the git, we knew about the creation of github and what its goal was. I think the goal was to create a network that people could save their work and use it whenever they need it.

03/09/21

During the class we starting learning more about GitHub and its commands, as I think all of us should know some information about the network which we use to save our projects there. We learnt about the difference between the staged and unstaged files, which were also familiar to us, because it simply included, git add, git commit and git push. At the last minutes of the lecture we discussed a question based on our new topic Big O Notations, and also got a home assignment to do.

06/09/21

Today we discussed new topic, about the types and concepts of the codes. According to the instructor, today was one of the most important lectures in order to continue the course. During the class I was able to understand the difference between the objects, models and concepts. First we declare the concept, then the model and in the end the object. We discussed different examples, during the lecture in order to better understand the topic. For example, University was mentioned as a model, and AUA was declared as an object. So it's like first when we declare concept, we explain what its objects include in order to better understand the following concept. Also the example of the types of numbers were discussed like the different types, for example integer, rational number, real number and natural number.

08/09/21

In today's lecture, we further discussed about containers, forward containers, reverse containers. We discussed about models, deques. And also we discussed about Random Access Containers. Also during the code reading we discussed about access.

13/09/21

In today's lecture, after learning about Containers,Random Access, Reverse Containers and Forward containers, we started to talk about sequences. Sequence is a variable sized container with strict linear ordered elements. There are two types of sequences, Front Insertion Sequences, which insert an element at the beginning and require constant time complexity, and Back Insertion Sequence which append an element on the end and also require amortized constant time complexity. We also got a reference from STL, which means Standard Templates Library. So we went on our discussion about the arrays and memory allocation on them. We also allocated memory with the number of bytes. We also discussed what free (ac) and delete[] ac++, for both c and c++ styles respectfully.

15/09/2021

In today's lecture, a pseudocode was written in otder to find a Random Access Container of an element.type, for(size.type i = 0, i < size) that we will need a for loop, and an access(c,i), which will return the element c[i]. For the size type function we need constant time complexity. We define this function in order to use it during the algorithm implementation. So we discussed the fact that we will be required to insert (array* a, element.type el, size.type pos). We were also reminded that sequence is a strict linear order. In other words the elements of the sequence are defined in row. An example was shown, where it was a container, but not a sequence. We again discussed and revised what function is, what is its actions in the code. We also figured out what typedef is, it is simply the way we use defining types in order to create a type in the code. When we strucutre an array named a, it means object a is located in the local memory. That array has double pointer start.type, element.type and size.type. I also understood that the type of the object a is array. The start type is element pointer type. In order to add this is a part of our homework that we will have to submit on Thursday midnight. If we simply print them, a random junk value will be printed, so we may need to initialize the value. It can be initialized with a value, in this example just s. We can also do memory allocation a sizeof (element.type). And always there are two things which are required in the function, which are the value and return. I also remembered what heap and stack memory were, one of them is dynamically allocated memory which begins the begining of the BSS segment and grows larger, and stack pointer simply segment the top values and is typically located in the higher parts of the memory. To conclude, we were trying to discuss a part of our homework especially the element type pointer and size type, by remembering some topics from this and past semesters.

17/09/2021

In today's lecture we discussed our homework assignment, and brought different similar examples and a pseudocode in order to better understand what our assignment was. It simply included inserting an element in array. But we also learnt what happens when we remove an element from an array. It includes the object and the position of it, and the element is removed, but yet, if there are other elements in the higher positions, the next position's element becomes the element of the position, which element was removed. It means we simply return an array, where an element is removed and as a result we return a new array with an element less from the previous array we inserted in the code. While inserting an array we use start and size. Then we create another array with the double size of the previous one, and simply do memory allocation from the previous array to the new one, in short the elements of the array is being allocated to a new double sized array. But after that the capacity stays the same.
